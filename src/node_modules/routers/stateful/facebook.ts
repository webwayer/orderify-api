import { Router } from 'express'
import { storage } from 'pkgcloud'
import * as request from 'request'
import { generateStartOauthUrl, exchangeCodeForAcessToken, getFacebookUserProfile, getFacebookAlbums, getFacebookPhotos } from 'scripts/facebook'
import { randomBytes } from 'crypto'
import { UserType } from 'database/User'
import { AlbumType } from 'database/Album'
import { PhotoType } from 'database/Photo'

export function facebookLoginRouterFactory(router: Router, config: FACEBOOK_CONFIG & { BASE_URL: string }, User: UserType, Album: AlbumType, Photo: PhotoType, storage: storage.Client) {
    const redirect_uri = `${config.BASE_URL}/login/facebook/callback`

    router.get('/login/facebook', async (req, res) => {
        const csrf_token = await cryptoRandomBytes(128)

        req.session.facebook_login_csrf_token = csrf_token

        const queryParams = {
            redirect_uri,
            scope: 'email,user_photos',
            client_id: config.FACEBOOK_CLIENT_ID,
            state: csrf_token,
            response_type: 'code,granted_scopes'
        }

        const facebookLoginUrl = generateStartOauthUrl(queryParams)

        res.redirect(facebookLoginUrl)
    })

    router.get('/login/facebook/callback', async (req, res) => {
        const { code, granted_scopes, denied_scopes, state, error_reason, error, error_description } = req.query

        if (!error && state === req.session.facebook_login_csrf_token) {
            const { access_token, expires_in, token_type } = await exchangeCodeForAcessToken({
                code,
                redirect_uri,
                client_id: config.FACEBOOK_CLIENT_ID,
                client_secret: config.FACEBOOK_CLIENT_SECRET,
            })

            const accessData = {
                access_token,
                expires_in,
                token_type,
                granted_scopes,
                denied_scopes,
            }

            if (access_token) {
                const facebookUserProfile = await getFacebookUserProfile(access_token, 'me', {
                    fields: 'email,id,first_name,last_name,middle_name,name,name_format,picture,short_name'
                })

                let user = await User.findOne({ where: { email: facebookUserProfile.email } })
                if (!user) {
                    user = await registrateUserFromFacebook(User, facebookUserProfile, accessData)
                } else {
                    await updateUserFromFacebook(User, user.id, facebookUserProfile, accessData)
                }

                await new Promise((resolve, reject) => {
                    req.session.regenerate(err => err ? reject(err) : resolve())
                })

                await uploadPhotoLibraryFromFacebook(storage, Album, Photo, user.id, access_token)

                req.session.userId = user.id
            }
        }

        res.redirect('/photos')
    })

    return router;

    // HELPERS

    async function registrateUserFromFacebook(User: UserType, facebookUserProfile, accessData: FacebookAccessData) {
        return await User.create({
            email: facebookUserProfile.email,
            name: facebookUserProfile.short_name,
            facebook: JSON.stringify({
                facebookUserProfile,
                accessData,
                createdAt: new Date(),
                updatedAt: new Date(),
            })
        })
    }

    async function updateUserFromFacebook(User: UserType, userId: number, facebookUserProfile, accessData: FacebookAccessData) {
        const user = await User.findByPk(userId)

        const facebookMetadata = JSON.parse(user.facebook)
        facebookMetadata.facebookUserProfile = facebookUserProfile
        facebookMetadata.updatedAt = new Date()
        facebookMetadata.accessData = accessData

        await user.update({
            facebook: JSON.stringify(facebookMetadata)
        })
    }

    async function uploadPhotoLibraryFromFacebook(storage: storage.Client, Album: AlbumType, Photo: PhotoType, userId: number, access_token: string) {
        const albums = await getFacebookAlbums(access_token, 'me', {
            limit: 1000,
            fields: 'name,type,created_time,updated_time'
        })

        const library = []
        for (const album of albums) {
            if (album.type === 'profile') {
                library.push(Object.assign({}, album, {
                    photos: await getFacebookPhotos(access_token, album.id, {
                        limit: 1000,
                        fields: 'name,alt_text,images,created_time,updated_time,album'
                    })
                }))
            }
        }

        for (const album of library) {
            const ourAlbum = await Album.create({
                name: album.name,
                userId,
                facebook: JSON.stringify(albums.find(alb => album.id === alb.id))
            })

            const photosToCreate = album.photos.map(photo => {
                const image = photo.images.find(image => image.width + image.height < 2000)

                return {
                    name: photo.name,
                    alt_text: photo.alt_text,
                    userId,
                    albumId: ourAlbum.id,
                    facebook: JSON.stringify(photo),
                    link: image.source,
                    width: image.width,
                    height: image.height,
                }
            })

            const ourPhotos = await Photo.bulkCreate(photosToCreate)

            // should be awaited some time
            Promise.all(ourPhotos.map(ourPhoto => {
                const readStream = request.get(ourPhoto.link)
                const writeStream = storage.upload({
                    container: 'photos',
                    remote: ourPhoto.id.toString(),
                })

                return promisifiedPipe(readStream, writeStream)
            }))
        }
    }
}

interface FACEBOOK_CONFIG {
    FACEBOOK_CLIENT_ID: string,
    FACEBOOK_CLIENT_SECRET: string,
}

interface FacebookAccessData {
    access_token: string
    expires_in: number
    token_type: string
    granted_scopes: string
    denied_scopes: string
}

async function cryptoRandomBytes(num: number): Promise<string> {
    return await new Promise((resolve, reject) => {
        randomBytes(num, function (err, buffer) {
            if (err) {
                reject(err)
            }
            resolve(buffer.toString('hex'))
        });
    })
}

/**
 * Streams input to output and resolves only after stream has successfully ended.
 * Closes the output stream in success and error cases.
 * @param input {stream.Readable} Read from
 * @param output {stream.Writable} Write to
 * @return Promise Resolves only after the output stream is "end"ed or "finish"ed.
 */
async function promisifiedPipe(input, output) {
    let ended = false;
    function end() {
        if (!ended) {
            ended = true;
            output.close && output.close();
            input.close && input.close();
            return true;
        }
    }

    return new Promise((resolve, reject) => {
        input.pipe(output);
        input.on('error', errorEnding);

        function niceEnding() {
            if (end()) resolve();
        }

        function errorEnding(error) {
            if (end()) reject(error);
        }

        output.on('finish', niceEnding);
        output.on('end', niceEnding);
        output.on('error', errorEnding);
    });
};