import { AlbumType } from 'photoLibrary/_/Album'
import { PhotoType } from 'photoLibrary/_/Photo'
import { storage } from 'pkgcloud'
import { facebookGraphFactory } from 'facebook/facebookGraphFactory'
import { RequestPromiseAPI } from 'request-promise'

export function photoLibraryOnFacebookFactory(request: RequestPromiseAPI, storage: storage.Client, Album: AlbumType, Photo: PhotoType, facebookGraph: ReturnType<typeof facebookGraphFactory>) {
    async function download(userId: number, access_token: string) {
        const albums = await facebookGraph.makeRequest(access_token, 'me', 'albums', {
            limit: 1000,
            fields: 'name,type,created_time,updated_time'
        })

        const library = []
        for (const album of albums) {
            if (album.type === 'profile') {
                library.push(Object.assign({}, album, {
                    photos: await facebookGraph.makeRequest(access_token, album.id, 'photos', {
                        limit: 1000,
                        fields: 'name,alt_text,images,created_time,updated_time,album'
                    })
                }))
            }
        }

        for (const album of library) {
            const ourAlbum = await Album.create({
                name: album.name,
                userId,
                facebook: JSON.stringify(albums.find(alb => album.id === alb.id))
            })

            const photosToCreate = album.photos.map(photo => {
                const image = photo.images.find(image => image.width + image.height < 2000)

                return {
                    name: photo.name,
                    alt_text: photo.alt_text,
                    userId,
                    albumId: ourAlbum.id,
                    facebook: JSON.stringify(photo),
                    link: image.source,
                    width: image.width,
                    height: image.height,
                }
            })

            const ourPhotos = await Photo.bulkCreate(photosToCreate)

            // should be awaited some time
            Promise.all(ourPhotos.map(ourPhoto => {
                const readStream = request.get(ourPhoto.link)
                const writeStream = storage.upload({
                    container: 'photos',
                    remote: ourPhoto.id.toString(),
                })

                return promisifiedPipe(readStream, writeStream)
            }))
        }
    }

    return {
        download
    }
}

/**
 * Streams input to output and resolves only after stream has successfully ended.
 * Closes the output stream in success and error cases.
 * @param input {stream.Readable} Read from
 * @param output {stream.Writable} Write to
 * @return Promise Resolves only after the output stream is "end"ed or "finish"ed.
 */
async function promisifiedPipe(input, output) {
    let ended = false;
    function end() {
        if (!ended) {
            ended = true;
            output.close && output.close();
            input.close && input.close();
            return true;
        }
    }

    return new Promise((resolve, reject) => {
        input.pipe(output);
        input.on('error', errorEnding);

        function niceEnding() {
            if (end()) resolve();
        }

        function errorEnding(error) {
            if (end()) reject(error);
        }

        output.on('finish', niceEnding);
        output.on('end', niceEnding);
        output.on('error', errorEnding);
    });
};